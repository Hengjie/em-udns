{"name":"EM-Udns","body":"## Overview\r\n\r\nEM-Udns is an async DNS resolver for [EventMachine](http://rubyeventmachine.com) based on [udns](http://www.corpit.ru/mjt/udns.html) C library. Having most of the code written in C, EM-Udns becomes very fast. It can resolve DNS A, AAAA, PTR, MX, TXT, SRV and NAPTR records, and can handle every kind of errors (domain/record not found, request timeout, malformed response...).\r\n\r\nC udns is a stub resolver, so also EM-Udns. This means that it must rely on a recursive name server, usually co-located in local host or local network. A very good choice is [Unbound](http://unbound.net), a validating, recursive and caching DNS resolver.\r\n\r\n\r\n## Usage Example\r\n\r\n    require \"em-udns\"\r\n\r\n    EM.run do\r\n      # Set the nameserver rather than using /etc/resolv.conf.\r\n      EM::Udns.nameservers = \"127.0.0.1\"\r\n      \r\n      resolver = EM::Udns::Resolver.new\r\n      EM::Udns.run resolver\r\n\r\n      query = resolver.submit_A \"google.com\"\r\n\r\n      query.callback do |result|\r\n        puts \"result => #{result.inspect}\"\r\n      end\r\n\r\n      query.errback do |error|\r\n        puts \"error => #{error.inspect}\"\r\n      end\r\n    end\r\n\r\nIt would produce following output:\r\n\r\n    result => [\"209.85.227.105\", \"209.85.227.103\", \"209.85.227.104\", \"209.85.227.106\", \"209.85.227.99\", \"209.85.227.147\"]\r\n\r\n\r\n## Setting the Nameservers\r\n\r\n    EM::Udns.nameservers = nameservers\r\n\r\nThis class method set the nameservers list to use for all the `EM::Udns::Resolver` instances. If not used, nameservers are taken from `/etc/resolv.conf` (default behavior). nameserver parameter can be:\r\n\r\n * `String` - The IP of a single nameserver.\r\n * Array of `String` -  IP's of multiple nameservers.\r\n\r\nIMPORTANT: This class method must be used before initializing any `EM::Udns::Resolver` instance.\r\n\r\nNOTE: Nameservers must be IPv4 addresses since [udns](http://www.corpit.ru/mjt/udns.html) does not listen in IPv6.\r\n\r\nExample 1:\r\n\r\n    EM::Udns.nameservers = \"127.0.0.1\"\r\n    \r\nExample 2:\r\n\r\n    EM::Udns.nameservers = [\"192.168.100.1\", \"192.168.100.2\"]\r\n    \r\n\r\n## Initializing a Resolver\r\n\r\n    resolver = EM::Udns::Resolver.new\r\n\r\nReturns a `EM::Udns::Resolver` instance. If there is an error an exception `EM::Udns::UdnsError` is raised.\r\n\r\n    \r\n## Runnig a Resolver\r\n\r\n    EM::Udns.run resolver\r\n\r\nAttaches the UDP socket of the resolver to EventMachine. This method must be called after EventMachine is running.\r\n\r\n\r\n## Async DNS Queries\r\n\r\n    resolver.submit_XXX(parameters)\r\n\r\nDNS queries are performed by invoking `EM::Udns::Resolver#submit_XXX(parameters)` methods on the resolver. The complete list of `submit_XXX` methods are shown below. These methods return a `EM::Udns::Query` instance. Callback and errback can then be assigned to the `Query` object via the `callback` and `errback` methods which accept a code block as single argument.\r\n\r\nIn case of success, the callback code block is invoked on the `EM::Udns::Query` object passing the DNS result object as single argument. Definition of those objects are shown below.\r\n\r\nIn case of error, the errback code block is invoked with the exact error as single argument, which is a Ruby Symbol:\r\n\r\n * `:dns_error_nxdomain` - The domain name does not exist.\r\n * `:dns_error_nodata` - The domain exists, but has no data of requested type.\r\n * `:dns_error_tempfail` - Temporary error, the resolver nameserver was not able to process our query or timed out.\r\n * `:dns_error_protocol` - Protocol error, a nameserver returned malformed reply.\r\n * `:dns_error_badquery` - Bad query, name of dn is invalid.\r\n * `:dns_error_nomem` - No memory available to allocate query structure.\r\n * `:dns_error_unknown` - An unknown error has occurred.\r\n\r\n\r\n## Type Specific Queries\r\n\r\n\r\n### A Record\r\n\r\n    resolver.submit_A(domain)\r\n\r\nIn case of success the callback is invoked passing as argument an array of `String` objects. Each `String` represents an IPv4 address.\r\n\r\nExample:\r\n\r\n    resolver.submit_A \"google.com\"\r\n\r\nCallback is called with argument:\r\n\r\n    [\"209.85.227.105\",\r\n     \"209.85.227.103\",\r\n     \"209.85.227.104\",\r\n     \"209.85.227.106\",\r\n     \"209.85.227.99\",\r\n     \"209.85.227.147\"]\r\n\r\n\r\n### AAAA Record\r\n\r\n    resolver.submit_AAAA(domain)\r\n\r\nIn case of success the callback is invoked passing as argument an array of `String` objects. Each `String` represents an IPv6 address.\r\n\r\nExample:\r\n\r\n    resolver.submit_AAAA \"sixxs.net\"\r\n\r\nCallback is called with argument:\r\n\r\n    [\"2001:838:2:1::30:67\",\r\n     \"2001:838:2:1:2a0:24ff:feab:3b53\",\r\n     \"2001:960:800::2\",\r\n     \"2001:1af8:4050::2\"]\r\n\r\n\r\n### MX Record\r\n\r\n    resolver.submit_MX(domain)\r\n\r\nIn case of success the callback is invoked passing as argument an array of `EM::Udns::RR_MX` objects. Such object contains the following attribute readers:\r\n\r\n * `domain` - `String` representing the domain of the MX record.\r\n * `priority` - `Fixnum` representing the priority of the MX record.\r\n\r\nExample:\r\n\r\n    resolver.submit_MX \"gmail.com\"\r\n\r\nCallback is called with argument:\r\n\r\n    [#<EventMachine::Udns::RR_MX:0x00000002289090 @domain=\"alt1.gmail-smtp-in.l.google.com\", @priority=10>,\r\n     #<EventMachine::Udns::RR_MX:0x00000002288e60 @domain=\"alt3.gmail-smtp-in.l.google.com\", @priority=30>,\r\n     #<EventMachine::Udns::RR_MX:0x000000022886e0 @domain=\"gmail-smtp-in.l.google.com\", @priority=5>,\r\n     #<EventMachine::Udns::RR_MX:0x00000002288618 @domain=\"alt2.gmail-smtp-in.l.google.com\", @priority=20>,\r\n     #<EventMachine::Udns::RR_MX:0x000000022883c0 @domain=\"alt4.gmail-smtp-in.l.google.com\", @priority=40>]\r\n\r\n\r\n### PTR Record\r\n\r\n    resolver.submit_PTR(ip)\r\n\r\nArgument ip must be a `String` representing a IPv4 or IPv6. In case of success the callback is invoked passing as argument an array of `String` objects. Each `String` represents a domain.\r\n\r\nExample 1:\r\n\r\n    resolver.submit_PTR \"8.8.8.8\"\r\n\r\nCallback is called with argument:\r\n\r\n    [\"google-public-dns-a.google.com\"]\r\n\r\nExample 2:\r\n\r\n    resolver.submit_PTR \"2001:838:2:1:2a0:24ff:feab:3b53\"\r\n\r\nCallback is called with argument:\r\n\r\n    [\"tunnelserver.concepts-ict.net\"]\r\n\r\n\r\n### TXT Record\r\n\r\n    resolver.submit_TXT(domain)\r\n\r\nIn case of success the callback is invoked passing as argument an array of `String` objects. Each `String` represents a text entry in the TXT result.\r\n\r\nExample:\r\n\r\n    resolver.submit_TXT \"gmail.com\"\r\n\r\nCallback is called with argument:\r\n\r\n    [\"v=spf1 redirect=_spf.google.com\"]\r\n\r\n    \r\n### SRV Record\r\n\r\n    resolver.submit_SRV(domain)\r\n    resolver.submit_SRV(domain, service, protocol)\r\n\r\nThere are two ways to perform a SRV query:\r\n\r\n * By passing as argument a single `String` (domain) with the format \"_service._protocol.domain\".\r\n * By passing three `String` arguments (domain, service and protocol).\r\n \r\nIn case of success the callback is invoked passing as argument an array of `EM::Udns::RR_SRV` objects. Such object contains the following attribute readers:\r\n\r\n * `domain` - `String` representing the A domain of the SRV record.\r\n * `port` - `Fixnum` representing the port of the SRV record.\r\n * `priority` - `Fixnum` representing the priority of the SRV record.\r\n * `weight` - `Fixnum` representing the weight of the SRV record.\r\n\r\nFor more information about these fields check [RFC 2782](http://tools.ietf.org/html/rfc2782).\r\n\r\nExample:\r\n\r\n    resolver.submit_SRV \"_sip._tcp.oversip.net\"\r\n\r\nor:\r\n\r\n    resolver.submit_SRV \"oversip.net\", \"sip\", \"tcp\"\r\n\r\nCallback is called with argument:\r\n\r\n    [#<EventMachine::Udns::RR_SRV:0x00000001ea4970 @domain=\"sip1.oversip.net\", @priority=1, @weight=50, @port=5062>,\r\n     #<EventMachine::Udns::RR_SRV:0x00000001ea4b50 @domain=\"sip2.oversip.net\", @priority=2, @weight=50, @port=5060>]\r\n     \r\n\r\n### NAPTR Record\r\n\r\n    resolver.submit_NAPTR(domain)\r\n\r\nIn case of success the callback is invoked passing as argument an array of `EM::Udns::RR_NAPTR` objects. Such object contains the following attribute readers:\r\n\r\n * `order` - `Fixnum` representing the order of the NAPTR record.\r\n * `preference` - `Fixnum` representing the preference of the NAPTR record.\r\n * `flags` - `String` representing the flags of the NAPTR record.\r\n * `service` - `String` representing the service of the NAPTR record.\r\n * `regexp` - `String` representing the regular expression field of the NAPTR record (`nil` in case `replacement` has value).\r\n * `replacement` - `String` representing the replacement string field of the NAPTR record (`nil` in case `regexp` has value).\r\n\r\nFor more information about these fields check [RFC 2915](http://tools.ietf.org/html/rfc2915).\r\n\r\nExample:\r\n\r\n    resolver.submit_NAPTR \"oversip.net\"\r\n\r\nCallback is called with argument:\r\n\r\n    [#<EventMachine::Udns::RR_NAPTR:0x00000002472aa0 @order=30, @preference=50, @flags=\"S\", @service=\"SIPS+D2T\", @regexp=nil, @replacement=\"_sips._tcp.oversip.net\">,\r\n     #<EventMachine::Udns::RR_NAPTR:0x00000002472848 @order=40, @preference=50, @flags=\"S\", @service=\"SIP+D2S\", @regexp=nil, @replacement=\"_sip._sctp.oversip.net\">,\r\n     #<EventMachine::Udns::RR_NAPTR:0x000000024723e8 @order=10, @preference=50, @flags=\"S\", @service=\"SIP+D2T\", @regexp=nil, @replacement=\"_sip._tcp.oversip.net\">,\r\n     #<EventMachine::Udns::RR_NAPTR:0x00000002471d80 @order=20, @preference=50, @flags=\"S\", @service=\"SIP+D2U\", @regexp=nil, @replacement=\"_sip._udp.oversip.net\">]\r\n\r\n\r\n## Other Features\r\n\r\n### Number of Active Queries\r\n\r\n    resolver.active\r\n\r\n`EM::Udns::Resolver#active` returns the number of pending queries of resolver as a `Fixnum`.\r\n\r\n\r\n### Cancelling a Pending Query\r\n\r\n    resolver.cancel query\r\n\r\n`EM::Udns::Resolver#cancel(query)` cancels the `EM::Udns::Query` given as argument so no callback/errback would be called upon query completion.\r\n\r\n\r\n## Installation\r\n\r\nEM-Udns is provided as a Ruby Gem:\r\n\r\n    ~$ gem install em-udns\r\n\r\n\r\n## Supported Platforms\r\n\r\nEM-Udns is tested under the following platforms:\r\n\r\n * Linux 32 and 64 bits\r\n * Mac OSX 32 and 64 bits\r\n\r\nSee also the [extconf.rb](https://github.com/ibc/em-udns/blob/master/ext/extconf.rb) file which compiles udns C library according to current platform.\r\n\r\n\r\n## TODO\r\n\r\n * Testing on other platforms.\r\n\r\n\r\n## Acknowledgement\r\n\r\nMany thanks to Michael Tokarev (the author of [udns](http://www.corpit.ru/mjt/udns.html) C library) for all the help provided in udns mailing list.","tagline":"An async DNS resolver for EventMachine based on udns C library","google":"UA-30651599-1","note":"Don't delete this file! It's used internally to help with page regeneration."}